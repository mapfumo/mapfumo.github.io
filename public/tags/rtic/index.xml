<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>RTIC on Antony Mapfumo</title>
    <link>http://localhost:1313/tags/rtic/</link>
    <description>Recent content in RTIC on Antony Mapfumo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Dec 2025 09:42:11 +1000</lastBuildDate><atom:link href="http://localhost:1313/tags/rtic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gateway Firmware - From Wireless to Desktop, Wk5</title>
      <link>http://localhost:1313/posts/gateway-firmware-from-wireless-to-desktop-wk5/</link>
      <pubDate>Sat, 13 Dec 2025 09:42:11 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/gateway-firmware-from-wireless-to-desktop-wk5/</guid>
      <description>&lt;p&gt;Week 5 was supposed to be straightforward: add USB-CDC to Node 2, stream JSON telemetry to the desktop. Simple, right?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spoiler&lt;/strong&gt;: The &amp;ldquo;simple&amp;rdquo; solution was blocked by hardware. Then the &amp;ldquo;good&amp;rdquo; solution was blocked by firmware. The &lt;strong&gt;working&lt;/strong&gt; solution came from adapting to constraints instead of fighting them.&lt;/p&gt;
&lt;p&gt;This is the story of how Week 5 became a lesson in &lt;strong&gt;engineering pragmatism&lt;/strong&gt; - and why the best solution isn&amp;rsquo;t always the most elegant one.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Binary Protocols and Reliable LoRa Communication</title>
      <link>http://localhost:1313/posts/binary-protocols-and-reliable-lora-communication/</link>
      <pubDate>Fri, 12 Dec 2025 20:14:18 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/binary-protocols-and-reliable-lora-communication/</guid>
      <description>&lt;p&gt;The first two weeks of this project focused on getting data moving: sensors reading correctly, LoRa modules talking, and messages arriving at the other end. That phase was intentionally simple and text-based. It worked, but it was never meant to last.&lt;/p&gt;
&lt;p&gt;This week was about moving closer to how real embedded systems behave in the field: binary data, explicit integrity checks, and predictable delivery behavior.&lt;/p&gt;
&lt;p&gt;Human-readable messages are convenient for debugging, but they waste bandwidth and hide failure modes. Radios don&amp;rsquo;t care about readability — they care about airtime, reliability, and determinism. This week&amp;rsquo;s work was about aligning the system with those realities.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LoRa Sensor Fusion: When &#34;Simple&#34; Becomes Reliable - Wk2</title>
      <link>http://localhost:1313/posts/lora-sensor-fusion-when-simple-becomes-reliable/</link>
      <pubDate>Fri, 05 Dec 2025 17:53:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/lora-sensor-fusion-when-simple-becomes-reliable/</guid>
      <description>&lt;p&gt;Building a reliable embedded system involves far more than getting code to compile. It&amp;rsquo;s a process of learning where hardware limits, timing guarantees, and data representation quietly shape everything above them.&lt;/p&gt;
&lt;p&gt;Week 2 of the Plan focused on making those constraints explicit.&lt;/p&gt;
&lt;p&gt;The result is a dual-node LoRa sensor fusion system built on the STM32F446RE using Rust and RTIC 1.1 — not as a showcase, but as a foundation.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#the-objective&#34;&gt;The Objective&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#system-overview&#34;&gt;System Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#five-critical-lessons&#34;&gt;Five Critical Lessons&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-1-the-51-byte-myth-and-a-self-inflicted-limit&#34;&gt;Lesson 1: The 51-Byte Myth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-2-rtic-timing-when-helpful-code-becomes-harmful&#34;&gt;Lesson 2: UART Timing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-3-sensor-fusion-by-selection-not-averaging&#34;&gt;Lesson 3: Sensor Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-4-units-displays-and-small-lies-that-matter&#34;&gt;Lesson 4: Data Representation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-5-shared-hardware-forces-honest-design&#34;&gt;Lesson 5: Shared Hardware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#results-at-the-end-of-week-2&#34;&gt;Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why-this-matters-in-the-plan&#34;&gt;Why This Matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#next-steps-week-3-preview&#34;&gt;Next Steps&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;the-objective&#34;&gt;The Objective&lt;/h2&gt;
&lt;p&gt;The goal for this week was deliberately narrow:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building Deterministic IIoT Systems With Embedded Rust and RTIC</title>
      <link>http://localhost:1313/posts/building-deterministic-iiot-systems-with-embedded-rust-and-rtic/</link>
      <pubDate>Tue, 02 Dec 2025 17:53:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/building-deterministic-iiot-systems-with-embedded-rust-and-rtic/</guid>
      <description>&lt;p&gt;In the world of Industrial IoT (IIoT), reliability is everything. Sensors must read accurately, actuators must respond predictably, and communication must flow without surprises. On the embedded side, this means precise control of hardware resources, minimal overhead, and code that behaves deterministically. Enter Embedded Rust and RTIC—a pairing that gives engineers both safety and performance without compromise.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;why-embedded-rust&#34;&gt;Why Embedded Rust?&lt;/h2&gt;
&lt;p&gt;Rust’s focus on memory safety, zero-cost abstractions, and strict compile-time checks makes it ideal for embedded systems. Unlike C, Rust prevents &lt;strong&gt;entire classes of bugs&lt;/strong&gt; like null pointer dereferences or buffer overflows. When your MCU has just a few kilobytes of RAM, these protections are not optional—they’re essential.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
