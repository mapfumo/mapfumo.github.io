<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tech on Antony Mapfumo</title>
    <link>http://localhost:1313/categories/tech/</link>
    <description>Recent content in Tech on Antony Mapfumo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Dec 2025 20:14:18 +1000</lastBuildDate><atom:link href="http://localhost:1313/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Binary Protocols and Reliable LoRa Communication</title>
      <link>http://localhost:1313/posts/binary-protocols-and-reliable-lora-communication/</link>
      <pubDate>Fri, 12 Dec 2025 20:14:18 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/binary-protocols-and-reliable-lora-communication/</guid>
      <description>&lt;p&gt;The first two weeks of this project focused on getting data moving: sensors reading correctly, LoRa modules talking, and messages arriving at the other end. That phase was intentionally simple and text-based. It worked, but it was never meant to last.&lt;/p&gt;
&lt;p&gt;This week was about moving closer to how real embedded systems behave in the field: binary data, explicit integrity checks, and predictable delivery behavior.&lt;/p&gt;
&lt;p&gt;Human-readable messages are convenient for debugging, but they waste bandwidth and hide failure modes. Radios don&amp;rsquo;t care about readability — they care about airtime, reliability, and determinism. This week&amp;rsquo;s work was about aligning the system with those realities.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LoRa Sensor Fusion: When &#34;Simple&#34; Becomes Reliable - Wk2</title>
      <link>http://localhost:1313/posts/lora-sensor-fusion-when-simple-becomes-reliable/</link>
      <pubDate>Fri, 05 Dec 2025 17:53:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/lora-sensor-fusion-when-simple-becomes-reliable/</guid>
      <description>&lt;p&gt;Building a reliable embedded system involves far more than getting code to compile. It&amp;rsquo;s a process of learning where hardware limits, timing guarantees, and data representation quietly shape everything above them.&lt;/p&gt;
&lt;p&gt;Week 2 of the Plan focused on making those constraints explicit.&lt;/p&gt;
&lt;p&gt;The result is a dual-node LoRa sensor fusion system built on the STM32F446RE using Rust and RTIC 1.1 — not as a showcase, but as a foundation.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#the-objective&#34;&gt;The Objective&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#system-overview&#34;&gt;System Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#five-critical-lessons&#34;&gt;Five Critical Lessons&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-1-the-51-byte-myth-and-a-self-inflicted-limit&#34;&gt;Lesson 1: The 51-Byte Myth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-2-rtic-timing-when-helpful-code-becomes-harmful&#34;&gt;Lesson 2: UART Timing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-3-sensor-fusion-by-selection-not-averaging&#34;&gt;Lesson 3: Sensor Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-4-units-displays-and-small-lies-that-matter&#34;&gt;Lesson 4: Data Representation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-5-shared-hardware-forces-honest-design&#34;&gt;Lesson 5: Shared Hardware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#results-at-the-end-of-week-2&#34;&gt;Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why-this-matters-in-the-plan&#34;&gt;Why This Matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#next-steps-week-3-preview&#34;&gt;Next Steps&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;the-objective&#34;&gt;The Objective&lt;/h2&gt;
&lt;p&gt;The goal for this week was deliberately narrow:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building Deterministic IIoT Systems With Embedded Rust and RTIC</title>
      <link>http://localhost:1313/posts/building-deterministic-iiot-systems-with-embedded-rust-and-rtic/</link>
      <pubDate>Tue, 02 Dec 2025 17:53:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/building-deterministic-iiot-systems-with-embedded-rust-and-rtic/</guid>
      <description>&lt;p&gt;In the world of Industrial IoT (IIoT), reliability is everything. Sensors must read accurately, actuators must respond predictably, and communication must flow without surprises. On the embedded side, this means precise control of hardware resources, minimal overhead, and code that behaves deterministically. Enter Embedded Rust and RTIC—a pairing that gives engineers both safety and performance without compromise.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;why-embedded-rust&#34;&gt;Why Embedded Rust?&lt;/h2&gt;
&lt;p&gt;Rust’s focus on memory safety, zero-cost abstractions, and strict compile-time checks makes it ideal for embedded systems. Unlike C, Rust prevents &lt;strong&gt;entire classes of bugs&lt;/strong&gt; like null pointer dereferences or buffer overflows. When your MCU has just a few kilobytes of RAM, these protections are not optional—they’re essential.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building an IIoT Sensor Node With Embedded Rust and Stm32</title>
      <link>http://localhost:1313/posts/building-an-iiot-sensor-node-with-embedded-rust-and-stm32/</link>
      <pubDate>Tue, 18 Nov 2025 17:23:13 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/building-an-iiot-sensor-node-with-embedded-rust-and-stm32/</guid>
      <description>&lt;h2 id=&#34;1-introduction&#34;&gt;1. Introduction&lt;/h2&gt;
&lt;p&gt;I come from a networking background. For years, my world revolved around packets, routing tables, latency, and uptime. Over time, it became clear that the boundary between IT and OT (Operational Technology) was becoming less rigid as industrial systems moved onto standard IP networks. Networks were no longer just carrying business traffic — they were increasingly responsible for transporting sensor data, telemetry, and control signals from the physical world. That realization pushed me toward Industrial IoT (IIoT) and, inevitably, embedded systems.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deep Learning Specialisation - A Brief Course Review</title>
      <link>http://localhost:1313/posts/deep_learning_specialisation/</link>
      <pubDate>Fri, 21 Apr 2023 18:00:58 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/deep_learning_specialisation/</guid>
      <description>&lt;p&gt;I have just completed &lt;a href=&#34;https://www.coursera.org/instructor/andrewng&#34;&gt;Andrew Ng&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;https://www.coursera.org/specializations/deep-learning&#34;&gt;Deep Learning Specialisation&lt;/a&gt; course by &lt;a href=&#34;https://www.deeplearning.ai/&#34;&gt;deeplearning.ai&lt;/a&gt; available through &lt;a href=&#34;http://bit.ly/2WjYrPB&#34;&gt;Coursera&lt;/a&gt;. This is my summary and opinion of the course offering. The specialisation consists of 5 courses and it is suggested that they be completed in 3 months by devoting 11 hours per week. It really depends on your previous knowledge, experience and how quickly you can grasp the concepts. When stuck with the assignments and concepts I found the forum to be very helpful. I found the assignments to reasonably difficult. The only thing I didn&amp;rsquo;t like is that by forcing you to complete the given code (complete missing blanks) you are a bit constrained. For example it would be nice to state the function signature and leave it to the student to implement it in their own way. The good thing is that one can always make such suggestions through the forums. The courses don&amp;rsquo;t have to be completed in any particular order but I found it more helpful to follow the suggested order.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Iec 61850</title>
      <link>http://localhost:1313/posts/iec-61850/</link>
      <pubDate>Fri, 22 Apr 2022 18:30:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/iec-61850/</guid>
      <description>&lt;p&gt;The IEC 61850 is at the heart of data communications in the smart grid. The IEC (International Electrotechnical Commission) 61850 standard outlines a framework for communication between several single devices in the power system. The standard was designed to separate the data model from method of communication, address the importance of a structured approach to the design of substation automation systems, utilise existing technologies like Ethernet and TCP/IP, simplify system configuration, device measurement sharing and to enable vendor independence. Although the scope of the IEC 61850 standard was originally substation focussed applications are already operating on wide area substation-to-substation communication using various components of IEC 61850.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
