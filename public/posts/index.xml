<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Antony Mapfumo</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Antony Mapfumo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Jan 2026 10:34:48 +1000</lastBuildDate><atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Async Rust Gateway From Embedded Firmware to Cloud Infrastructure - wk6</title>
      <link>http://localhost:1313/posts/async-rust-gateway-from-embedded-firmware-to-cloud-infrastructure/</link>
      <pubDate>Sun, 04 Jan 2026 10:34:48 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/async-rust-gateway-from-embedded-firmware-to-cloud-infrastructure/</guid>
      <description>&lt;p&gt;Week 6 marks a fundamental shift in the project. Up through Week 5, everything stayed within the embedded realm - microcontrollers talking to each other over LoRa. Data lived in OLED displays and defmt logs that disappeared when you closed the terminal.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Week 6 changes that.&lt;/strong&gt; It&amp;rsquo;s the bridge between embedded and cloud, between constrained systems and abundant infrastructure, between &lt;code&gt;no_std&lt;/code&gt; and &lt;code&gt;std&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is the week I learned &lt;strong&gt;async Rust isn&amp;rsquo;t just about performance - it&amp;rsquo;s about building systems that compose.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gateway Firmware - From Wireless to Desktop, Wk5</title>
      <link>http://localhost:1313/posts/gateway-firmware-from-wireless-to-desktop-wk5/</link>
      <pubDate>Sat, 13 Dec 2025 09:42:11 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/gateway-firmware-from-wireless-to-desktop-wk5/</guid>
      <description>&lt;p&gt;Week 5 was supposed to be straightforward: add USB-CDC to Node 2, stream JSON telemetry to the desktop. Simple, right?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spoiler&lt;/strong&gt;: The &amp;ldquo;simple&amp;rdquo; solution was blocked by hardware. Then the &amp;ldquo;good&amp;rdquo; solution was blocked by firmware. The &lt;strong&gt;working&lt;/strong&gt; solution came from adapting to constraints instead of fighting them.&lt;/p&gt;
&lt;p&gt;This is the story of how Week 5 became a lesson in &lt;strong&gt;engineering pragmatism&lt;/strong&gt; - and why the best solution isn&amp;rsquo;t always the most elegant one.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Binary Protocols and Reliable LoRa Communication</title>
      <link>http://localhost:1313/posts/binary-protocols-and-reliable-lora-communication/</link>
      <pubDate>Fri, 12 Dec 2025 20:14:18 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/binary-protocols-and-reliable-lora-communication/</guid>
      <description>&lt;p&gt;The first two weeks of this project focused on getting data moving: sensors reading correctly, LoRa modules talking, and messages arriving at the other end. That phase was intentionally simple and text-based. It worked, but it was never meant to last.&lt;/p&gt;
&lt;p&gt;This week was about moving closer to how real embedded systems behave in the field: binary data, explicit integrity checks, and predictable delivery behavior.&lt;/p&gt;
&lt;p&gt;Human-readable messages are convenient for debugging, but they waste bandwidth and hide failure modes. Radios don&amp;rsquo;t care about readability — they care about airtime, reliability, and determinism. This week&amp;rsquo;s work was about aligning the system with those realities.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LoRa Sensor Fusion: When &#34;Simple&#34; Becomes Reliable - Wk2</title>
      <link>http://localhost:1313/posts/lora-sensor-fusion-when-simple-becomes-reliable/</link>
      <pubDate>Fri, 05 Dec 2025 17:53:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/lora-sensor-fusion-when-simple-becomes-reliable/</guid>
      <description>&lt;p&gt;Building a reliable embedded system involves far more than getting code to compile. It&amp;rsquo;s a process of learning where hardware limits, timing guarantees, and data representation quietly shape everything above them.&lt;/p&gt;
&lt;p&gt;Week 2 of the Plan focused on making those constraints explicit.&lt;/p&gt;
&lt;p&gt;The result is a dual-node LoRa sensor fusion system built on the STM32F446RE using Rust and RTIC 1.1 — not as a showcase, but as a foundation.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#the-objective&#34;&gt;The Objective&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#system-overview&#34;&gt;System Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#five-critical-lessons&#34;&gt;Five Critical Lessons&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-1-the-51-byte-myth-and-a-self-inflicted-limit&#34;&gt;Lesson 1: The 51-Byte Myth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-2-rtic-timing-when-helpful-code-becomes-harmful&#34;&gt;Lesson 2: UART Timing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-3-sensor-fusion-by-selection-not-averaging&#34;&gt;Lesson 3: Sensor Fusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-4-units-displays-and-small-lies-that-matter&#34;&gt;Lesson 4: Data Representation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lesson-5-shared-hardware-forces-honest-design&#34;&gt;Lesson 5: Shared Hardware&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#results-at-the-end-of-week-2&#34;&gt;Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why-this-matters-in-the-plan&#34;&gt;Why This Matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#next-steps-week-3-preview&#34;&gt;Next Steps&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;the-objective&#34;&gt;The Objective&lt;/h2&gt;
&lt;p&gt;The goal for this week was deliberately narrow:&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building Deterministic IIoT Systems With Embedded Rust and RTIC</title>
      <link>http://localhost:1313/posts/building-deterministic-iiot-systems-with-embedded-rust-and-rtic/</link>
      <pubDate>Tue, 02 Dec 2025 17:53:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/building-deterministic-iiot-systems-with-embedded-rust-and-rtic/</guid>
      <description>&lt;p&gt;In the world of Industrial IoT (IIoT), reliability is everything. Sensors must read accurately, actuators must respond predictably, and communication must flow without surprises. On the embedded side, this means precise control of hardware resources, minimal overhead, and code that behaves deterministically. Enter Embedded Rust and RTIC—a pairing that gives engineers both safety and performance without compromise.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;why-embedded-rust&#34;&gt;Why Embedded Rust?&lt;/h2&gt;
&lt;p&gt;Rust’s focus on memory safety, zero-cost abstractions, and strict compile-time checks makes it ideal for embedded systems. Unlike C, Rust prevents &lt;strong&gt;entire classes of bugs&lt;/strong&gt; like null pointer dereferences or buffer overflows. When your MCU has just a few kilobytes of RAM, these protections are not optional—they’re essential.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Building an IIoT Sensor Node With Embedded Rust and Stm32</title>
      <link>http://localhost:1313/posts/building-an-iiot-sensor-node-with-embedded-rust-and-stm32/</link>
      <pubDate>Tue, 18 Nov 2025 17:23:13 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/building-an-iiot-sensor-node-with-embedded-rust-and-stm32/</guid>
      <description>&lt;h2 id=&#34;1-introduction&#34;&gt;1. Introduction&lt;/h2&gt;
&lt;p&gt;I come from a networking background. For years, my world revolved around packets, routing tables, latency, and uptime. Over time, it became clear that the boundary between IT and OT (Operational Technology) was becoming less rigid as industrial systems moved onto standard IP networks. Networks were no longer just carrying business traffic — they were increasingly responsible for transporting sensor data, telemetry, and control signals from the physical world. That realization pushed me toward Industrial IoT (IIoT) and, inevitably, embedded systems.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Design Science: A Disciplined Approach to Engineering Embedded Systems</title>
      <link>http://localhost:1313/posts/design-science-a-disciplined-approach-to-software-development/</link>
      <pubDate>Mon, 20 Oct 2025 14:20:17 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/design-science-a-disciplined-approach-to-software-development/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Design Science&lt;/strong&gt; is a research methodology and problem-solving framework that focuses on the &lt;strong&gt;creation and evaluation of artifacts&lt;/strong&gt; designed to solve real-world problems. Rather than studying systems passively, Design Science emphasizes &lt;strong&gt;active construction, experimentation, and rigorous evaluation&lt;/strong&gt;. Its principles have traditionally been applied in information systems and software development, but they are equally relevant to modern embedded and IIoT engineering.&lt;/p&gt;
&lt;p&gt;In complex engineering domains — including &lt;strong&gt;embedded systems, IoT, and distributed sensor networks&lt;/strong&gt; — the challenge is not just writing code or assembling hardware. It’s about systematically creating artifacts that &lt;strong&gt;solve practical problems effectively, reliably, and efficiently&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Machine Learning web application using Python, Scikit-Learn, Flask</title>
      <link>http://localhost:1313/posts/machine-learning-flask/</link>
      <pubDate>Thu, 27 Apr 2023 12:02:35 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/machine-learning-flask/</guid>
      <description>&lt;p&gt;The scikit-learn Iris data-set consists of 3 (Setosa, Versicolour, and Virginica) species (50 samples per species, for a total of 150 samples) of the iris flower. Each sample has four measurements: sepal length, sepal width, petal length, petal width. Given these measurements a machine learning model can predict the iris specie with a high degree of accuracy. Here I demonstrate a machine learning web application using &lt;em&gt;Python&lt;/em&gt;, &lt;em&gt;Scikit-Learn&lt;/em&gt; machine learning library and &lt;em&gt;Flask&lt;/em&gt; web framework. The application is then deployed on an Amazon EC2 instance. The source is on &lt;strong&gt;&lt;a href=&#34;https://github.com/mapfumo/iris-flask&#34;&gt;GitHub&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Programming with Google Go Specialization - A Brief Course Review</title>
      <link>http://localhost:1313/posts/go_specialisation/</link>
      <pubDate>Sat, 22 Apr 2023 17:33:35 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/go_specialisation/</guid>
      <description>&lt;p&gt;Go or &lt;a href=&#34;golang.org&#34;&gt;GoLang&lt;/a&gt; is an open source statically typed language that was created at Google by Rob Pike, Robert Griesemer, and Ken Thompson. It first appeared in Nov 2009 and has been rapidly gaining in popularity. Some of the language&amp;rsquo;s highlights include clean and highly accessible syntax, garbage collection,  amazing native concurrency, fast compilation speed, excellent tooling, builtin documentation, good cross-platform support, ORM (Object-relational mapping ) library called GORM and excellent support for micro-services.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deep Learning Specialisation - A Brief Course Review</title>
      <link>http://localhost:1313/posts/deep_learning_specialisation/</link>
      <pubDate>Fri, 21 Apr 2023 18:00:58 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/deep_learning_specialisation/</guid>
      <description>&lt;p&gt;I have just completed &lt;a href=&#34;https://www.coursera.org/instructor/andrewng&#34;&gt;Andrew Ng&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;https://www.coursera.org/specializations/deep-learning&#34;&gt;Deep Learning Specialisation&lt;/a&gt; course by &lt;a href=&#34;https://www.deeplearning.ai/&#34;&gt;deeplearning.ai&lt;/a&gt; available through &lt;a href=&#34;http://bit.ly/2WjYrPB&#34;&gt;Coursera&lt;/a&gt;. This is my summary and opinion of the course offering. The specialisation consists of 5 courses and it is suggested that they be completed in 3 months by devoting 11 hours per week. It really depends on your previous knowledge, experience and how quickly you can grasp the concepts. When stuck with the assignments and concepts I found the forum to be very helpful. I found the assignments to reasonably difficult. The only thing I didn&amp;rsquo;t like is that by forcing you to complete the given code (complete missing blanks) you are a bit constrained. For example it would be nice to state the function signature and leave it to the student to implement it in their own way. The good thing is that one can always make such suggestions through the forums. The courses don&amp;rsquo;t have to be completed in any particular order but I found it more helpful to follow the suggested order.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Iec 61850</title>
      <link>http://localhost:1313/posts/iec-61850/</link>
      <pubDate>Fri, 22 Apr 2022 18:30:41 +1000</pubDate>
      
      <guid>http://localhost:1313/posts/iec-61850/</guid>
      <description>&lt;p&gt;The IEC 61850 is at the heart of data communications in the smart grid. The IEC (International Electrotechnical Commission) 61850 standard outlines a framework for communication between several single devices in the power system. The standard was designed to separate the data model from method of communication, address the importance of a structured approach to the design of substation automation systems, utilise existing technologies like Ethernet and TCP/IP, simplify system configuration, device measurement sharing and to enable vendor independence. Although the scope of the IEC 61850 standard was originally substation focussed applications are already operating on wide area substation-to-substation communication using various components of IEC 61850.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
